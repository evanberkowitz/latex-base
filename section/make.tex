\section{Makefile}\label{sec:make}

The provided \texttt{Makefile} uses \texttt{pdflatex} and \texttt{bibtex} to compile \texttt{master.pdf}, the base of which is set in the \texttt{MASTER} variable.
You can change the executables in the \texttt{TEX} and \texttt{BIB} variables.  It has been carefully constructed so that if the user (or, say, their collaborators) do not compile using the \texttt{Makefile}, nothing bad happens or goes wrong.

\subsection{Targets}

The default target is \texttt{\$(MASTER).pdf}, drawn from \texttt{\$(MASTER).tex}.
You can add other root-level documents and simply do \texttt{make other-document.pdf} without adding new rules to the \texttt{Makefile}.
The PDF targets depend on the files in the \texttt{section} directory, \texttt{macros.tex}, all \texttt{.bib} files in the repository, and the corresponding root-level \texttt{tex} document.

The \texttt{tidy} target gets rid of temporary files generated by \LaTeX, while the \texttt{clean} target gets rid of additional files and the generated PDF.  Both understand the \texttt{TARGET} flag.

The \texttt{git-hooks} target symbolically links the hooks in the \texttt{hooks} directory into the \texttt{.git/hooks} directory.  The hooks are discussed in \Secref{hooks}.

The \texttt{watch} target monitors the repository for file changes and continuously rebuilds \texttt{\$(TARGET).pdf}.  It relies on \texttt{when-changed}\cite{when-changed}.
This can interfere with the pre-commit \git hook.
It can also get stuck in an infinite loop if the PDF does not compile correctly.
But if you tend to write decent \LaTeX the first time around, it'll be pretty reliable.


\subsection{User Flags}

The \texttt{TARGET} variable defaults to \texttt{\$(MASTER)} but can be overridden.  It is useful for the \texttt{tidy}, \texttt{clean}, and \texttt{watch} targets.
It should take the value of the prefix of the PDF file you wish to generate; if you want to continuously generate \texttt{foo.pdf} and \texttt{foo.tex} is at the root level of the repo, you can simply do \texttt{make watch TARGET=foo}.
The \texttt{tidy} and \texttt{clean} targets operate similarly.

The \texttt{FINAL} variable controls whether the result of \texttt{./repo/\$(REPO).sh} is used as part of the preamble to the \texttt{tex} file.  The result is used by default, set \texttt{FINAL=1} to remove it.

The \texttt{DIFF} variable decides whether the resulting PDF indicates differences between the \texttt{OLD} and \texttt{NEW} repository states, using \texttt{git latexdiff}\cite{git-latexdiff}.  \texttt{OLD} defaults to the SHA of the latest commit and \texttt{NEW} to \texttt{-{}-}, indicating the current state of the repo (including unstaged changes, but NOT including untracked files).  In this repo, for example, you can
\begin{verbatim}
	make DIFF=1 OLD=df58f60 NEW=93d2abc
\end{verbatim}
If \texttt{OLD} is later than \texttt{NEW}, I don't know what happens in general.
If you use a different version control system, you should change the defaults for \texttt{OLD} and \texttt{NEW} (and, presumably change the diff generator to something other than \texttt{git latexdiff}).

\subsection{Other \texttt{Makefile} Variables}

There are variables in the \texttt{Makefile} that presumably don't need to change once they're set.
The \texttt{REPO}, \texttt{OLD}, \texttt{NEW}, \texttt{ROOT}, and \texttt{MASTER} variables are examples.

The \texttt{SHORTCIRCUIT} variable should not be used by the user.
The difficulty was that once the user sets the \texttt{DIFF} flag, \texttt{git latexdiff} uses the \texttt{Makefile} to build the diff, and the \texttt{DIFF} flag is passed along.  So, \texttt{git latexdiff} would be invoked in an infinite loop.
Defining \texttt{SHORTCIRCUIT} breaks that loop.
